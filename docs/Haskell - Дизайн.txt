Говорят, каждый программист должен в своей жизни написать хотя бы один компилятор или придумать какой-нибудь язык программирования. Дизайн нового языка - дело непростое, ведь нужно продумать десятки параметров, которые, как кубики Lego, должны хорошо между собой сочетаться. Одно неудачное решение может перечеркнуть судьбу языка, когда он еще даже не вышел в свет. Сотни языков прозябают в забвении, подвинутые с подиума старшими братьями, но мир с упорством, достойным лучшего применения, рождает ежегодно два-три новых. Попадут ли они хотя бы в "группу альтернативного мировоззрения", или даже станут мэйнстримными, покажет время. К счастью, моему языку это не нужно, поскольку на нем нельзя программировать, - им можно только любоваться. Ибо это язык визуализации Haskell-кода, о дизайне которого пойдет речь в статье.

===============(картинка - визуализация)===============

Haskell - замечательный язык. Он очень выразительный и емкий. Код получается на порядок компактнее кода на императивных языках (C++, Java, C#), несмотря на то, что в нем меньше синтаксических конструкций. Чистая функциональная природа Haskell и его дизайн способствуют тому, что код становится похож на математическую запись. Возьмем для примера показательный (но не лучший) вариант факториала:

<blockquote>fact&nbsp;n&nbsp;<font color="#339933">|</font>&nbsp;n&nbsp;<font color="#339933">==</font>&nbsp;<font>0</font>&nbsp;<font color="#339933">=</font>&nbsp;<font>1</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">|</font>&nbsp;n&nbsp;<font color="#339933">&gt;</font>&nbsp;&nbsp;<font>0</font>&nbsp;<font color="#339933">=</font>&nbsp;n&nbsp;<font color="#339933">*</font>&nbsp;fact&nbsp;<font>&#40;</font>n<font color="#339933">-</font><font>1</font><font>&#41;</font></blockquote>

В этих двух строчках отлично узнается знакомая со школы рекуррентная формула факториала:

==============(картинка с Википедии)===========

Конечно, определенный рекурсивно факториал не будет сильно хуже на любом другом языке, что может вызвать сомнения, а так уж ли Haskell выразителен.

<blockquote><font color="#0000ff">int</font>&nbsp;fact<font color="#008000">&#40;</font><font color="#0000ff">int</font>&nbsp;n<font color="#008000">&#41;</font><br/>
<font color="#008000">&#123;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">if</font>&nbsp;<font color="#008000">&#40;</font>n&nbsp;<font color="#000080">==</font>&nbsp;<font color="#0000dd">0</font><font color="#008000">&#41;</font>&nbsp;<font color="#0000ff">return</font>&nbsp;<font color="#0000dd">1</font><font color="#008080">;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">return</font>&nbsp;n&nbsp;<font color="#000040">*</font>&nbsp;fact&nbsp;<font color="#008000">&#40;</font>n&nbsp;<font color="#000040">-</font>&nbsp;<font color="#0000dd">1</font><font color="#008000">&#41;</font><font color="#008080">;</font><br/>
<font color="#008000">&#125;</font></blockquote>

Фокус в том, что обе функции написаны в функциональном стиле, поэтому между ними особой разницы и нет. Однако, пожалев стек, мы могли бы в императивном языке использовать цикл, что выглядит уже совсем по-другому:

<blockquote><font color="#0000ff">int</font>&nbsp;fact<font color="#008000">&#40;</font><font color="#0000ff">int</font>&nbsp;n<font color="#008000">&#41;</font><br/>
<font color="#008000">&#123;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">int</font>&nbsp;f&nbsp;<font color="#000080">=</font>&nbsp;<font color="#0000dd">1</font><font color="#008080">;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">for</font>&nbsp;<font color="#008000">&#40;</font><font color="#0000ff">int</font>&nbsp;i&nbsp;<font color="#000080">=</font>&nbsp;<font color="#0000dd">2</font><font color="#008080">;</font>&nbsp;i&nbsp;<font color="#000080">&lt;=</font>&nbsp;n<font color="#008080">;</font>&nbsp;<font color="#000040">++</font>i<font color="#008000">&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;<font color="#000040">*</font><font color="#000080">=</font>&nbsp;i<font color="#008080">;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000ff">return</font>&nbsp;f<font color="#008080">;</font><br/>
<font color="#008000">&#125;</font></blockquote>

Программисты хорошо знают о том, что визуализировать последние два примера можно с помощью блок-схемы:

=====================(2 блок-схемы: циклическая, рекурсивная)====================

Вторая схема, в принципе, описывает, что происходит и в рекурсивном коде на Haskell. И хотя блок-схемы - это визуализация, они все-таки отличаются от того, что хочу я: они показывают, __что__ происходит, а не __как выглядит__. Я же хочу перенести код на трехмерную сцену, - так, чтобы сцена получилась красивой, интуитивной и по возможности необычной. Смысл визуализации есть в этом.

При дизайне языка приходится думать над тем, как его потом расширять. Сделаешь неверно или неудобно, - и новым затеям не будет места без того, чтобы разрушить обратную совместимость. Истории такие примеры известны; не миновала сия чаша даже некоторые очень популярные языки (например, Python 3.0, который не совместим с ранними версиями). В значительной мере на расширяемость дизайна влияют совсем малые вещи, так сказать, синтаксис в малом. При удачных детальках весь язык строится как один большой и хорошо продуманный конструктор. Haskell из таких, а значит, язык визуализации тоже должен держать марку. И тут я даже не могу сделать скидку на то, что дизайн Haskell известен, - мне все равно приходится преодолевать эти трудности с самого начала. Хотя в некотором смысле мне, конечно же, проще.

Итак, нужно продумать дизайн графического языка, достаточно самостоятельный, но при этом наглядный и эстетически полезный. Думать нужно над отдельными синтаксическими единицами, в то же время поглядывая на уровень выше - на их связь и на их значение в общей канве. Отталкиваясь от того самого факториала, я планирую когда-нибудь придумать эскизы даже для такого вот Haskell-кода:

<blockquote><font color="#5d478b">--&nbsp;|&nbsp;Collects&nbsp;actions&nbsp;for&nbsp;specified&nbsp;box&nbsp;side&nbsp;drawings.</font><br/>
<font color="#5d478b">--&nbsp;|&nbsp;It&nbsp;should&nbsp;be&nbsp;used&nbsp;only&nbsp;in&nbsp;this&nbsp;module.</font><br/>
f&nbsp;<font color="#339933">::</font>&nbsp;PreparedTextureObjects<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;GLfVertex3&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#40;</font>BoxSide<font color="#339933">,</font>&nbsp;QuadColorSpec<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#40;</font><font>&#91;</font>BoxSide<font>&#93;</font><font color="#339933">,</font>&nbsp;<font>&#91;</font><font color="#cccc00">IO</font><font>&#40;</font><font>&#41;</font><font>&#93;</font><font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#40;</font><font>&#91;</font>BoxSide<font>&#93;</font><font color="#339933">,</font>&nbsp;<font>&#91;</font><font color="#cccc00">IO</font><font>&#40;</font><font>&#41;</font><font>&#93;</font><font>&#41;</font><br/>
f&nbsp;texRes&nbsp;boxDim&nbsp;<font>&#40;</font>side<font color="#339933">,</font>&nbsp;qColorSpec<font>&#41;</font>&nbsp;<font>&#40;</font>sList<font color="#339933">,</font>&nbsp;ioList<font>&#41;</font>&nbsp;<font color="#339933">=</font>&nbsp;<font>let</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;boxIO&nbsp;<font color="#339933">=</font>&nbsp;<font>do</font>&nbsp;&nbsp;setQuadColorSpec&nbsp;texRes&nbsp;qColorSpec<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL<font color="#339933">.</font>renderPrimitive&nbsp;GL<font color="#339933">.</font>Quads&nbsp;<font>&#40;</font>boxSide&nbsp;boxDim&nbsp;side<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font>in</font>&nbsp;<font>&#40;</font>side&nbsp;:&nbsp;sList<font color="#339933">,</font>&nbsp;boxIO&nbsp;:&nbsp;ioList<font>&#41;</font>&nbsp;</blockquote>

Или для такого:

<blockquote><font>data</font>&nbsp;QuadColorSpec&nbsp;<font color="#339933">=</font>&nbsp;QuadTexture&nbsp;TextureName<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">|</font>&nbsp;QuadPlainColor&nbsp;GLfColor4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">|</font>&nbsp;NoQuadColorSpec<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font>deriving</font>&nbsp;<font>&#40;</font><font color="#cccc00">Show</font><font>&#41;</font><br/>
&nbsp;<br/>
<font>data</font>&nbsp;ObjectTextureSpec&nbsp;<font color="#339933">=</font>&nbsp;BoxTextureSpec<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>&#123;</font>&nbsp;quadSideTexes&nbsp;&nbsp;<font color="#339933">::</font>&nbsp;<font>&#91;</font><font>&#40;</font>BoxSide<font color="#339933">,</font>&nbsp;QuadColorSpec<font>&#41;</font><font>&#93;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">,</font>&nbsp;defQuadSideTex&nbsp;<font color="#339933">::</font>&nbsp;QuadColorSpec<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>&#125;</font>&nbsp;<font>deriving</font>&nbsp;<font>&#40;</font><font color="#cccc00">Show</font><font>&#41;</font><br/>
&nbsp;<br/>
<font>data</font>&nbsp;CornerCoord&nbsp;<font color="#339933">=</font>&nbsp;UR&nbsp;<font color="#339933">|</font>&nbsp;DR&nbsp;<font color="#339933">|</font>&nbsp;DL&nbsp;<font color="#339933">|</font>&nbsp;UL&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font>deriving</font>&nbsp;<font>&#40;</font><font color="#cccc00">Show</font><font>&#41;</font></blockquote>

А пока у меня есть код факториала, с него и начинался язык визуализации:

<blockquote>fact&nbsp;n&nbsp;<font color="#339933">|</font>&nbsp;n&nbsp;<font color="#339933">==</font>&nbsp;<font>0</font>&nbsp;<font color="#339933">=</font>&nbsp;<font>1</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">|</font>&nbsp;n&nbsp;<font color="#339933">/=</font>&nbsp;<font>0</font>&nbsp;<font color="#339933">=</font>&nbsp;fact&nbsp;<font>&#40;</font>n&nbsp;<font color="#339933">-</font>&nbsp;<font>1</font><font>&#41;</font>&nbsp;<font color="#339933">*</font>&nbsp;n</blockquote>

Здесь мы видим несколько синтаксических конструкций:

<table>
<tr><td>название функции</td><td><pre>    </pre></td><td>fact</td></tr>
<tr><td>2 охранных выражения</td><td></td><td>| n == 0</td></tr>
<tr><td></td><td></td><td>| n /= 0</td></tr>
<tr><td>2 тела функции</td><td></td><td>= 1</td></tr>
<tr><td></td><td></td><td>= fact (n - 1) * n</td></tr>
</table>

В свою очередь, каждое тело функции разбивается на древовидное вычислительное выражение. Возьмем второй случай. Представляя элементы этого дерева в виде коробок, мы получим первый грубый вариант:

============(грубый эскиз выражения в непирамидальной форме)==================

И сразу же проступают недостатки. Можно представить, как вырастет визуализация кода, если добавить в тело функции еще каких-нибудь действий и выражений. Да что там! Выражения могут сами состоять из выражений, и простое соотнесение каждого элемента с коробкой приведет к тому, что мы просто получим длинную и неинтуитивную цепь из коробок. Решение "в лоб" здесь не подходит. Вспомним полезный факт: явным воплощением древовидной конструкции является пирамида. Вычислительное выражение тоже можно представить в таком виде, причем даже несколькими способами:

=========(2 эскиза выражения в пирамидальной форме)============

Последняя картинка субъективно симпатичнее за счет характерных пирамидальных выступов. Можно было бы остановиться на этой форме, но есть у бинарных функций особенность, что они могут быть операторами. Отличие операторов от функций чисто интуитивное, а с точки зрения языка это одно и то же, просто по-разному записывается - в функциональной и инфиксной записях:

<blockquote>isListElement&nbsp;&nbsp;x&nbsp;xs&nbsp;<font color="#339933">=</font>&nbsp;<font>elem</font>&nbsp;x&nbsp;xs&nbsp;&nbsp;&nbsp;<font color="#5d478b">--&nbsp;функциональная&nbsp;форма</font><br/>
isListElement’&nbsp;x&nbsp;xs&nbsp;<font color="#339933">=</font>&nbsp;x&nbsp;`<font>elem</font>`&nbsp;xs&nbsp;<font color="#5d478b">--&nbsp;инфиксная&nbsp;форма</font></blockquote>

Операторы по умолчанию используются в инфиксной записи, но допустима и функциональная тоже:

<blockquote>add&nbsp;a&nbsp;b&nbsp;<font color="#339933">=</font>&nbsp;a&nbsp;<font color="#339933">+</font>&nbsp;b<br/>
add’&nbsp;a&nbsp;b&nbsp;<font color="#339933">=</font>&nbsp;<font>&#40;</font><font color="#339933">+</font><font>&#41;</font>&nbsp;a&nbsp;b</blockquote>

И этот факт можно легко отобразить при визуализации. На следующем эскизе помимо выделения инфиксной формы я увеличил конечные синтаксические единицы (переменные и константы) в два раза:

================(Финальный эскиз пирамидального выражения)===============

Уменьшилась высота пирамиды, что хорошо, и стало видно, где инфиксная запись, а где - функциональная. Такой подход становится полезен при задании идущих подряд вычислений:

<blockquote>add3&nbsp;a&nbsp;b&nbsp;c&nbsp;<font color="#339933">=</font>&nbsp;a&nbsp;<font color="#339933">+</font>&nbsp;b&nbsp;<font color="#339933">+</font>&nbsp;c<br/>
someF&nbsp;x&nbsp;y&nbsp;z&nbsp;<font color="#339933">=</font>&nbsp;x&nbsp;<font color="#339933">&gt;&gt;=</font>&nbsp;y&nbsp;<font color="#339933">&gt;&gt;</font>&nbsp;z</blockquote>

========(Эскиз (2 картинки) с последовательными инфиксными выражениями)==========

А для функций с большим числом аргументов стоит сохранить промежуток между коробками.

=======(Эскиз foldr с 3 аргументами)==========

На эскизах видно, что длина коробок зависит от названия на коробке и от места, занимаемого аргументами. Тут уж ничего не поделаешь: надпись нужна, и уменьшать ее в размерах не стоит, иначе мы потеряем единообразие. Это на web-страничке или в документе каком-нибудь можно шрифты подгонять, а код должен выглядеть строго, потому что его так легче читать. Поэтому сложные, массивные вычислительные выражения будут выглядеть тоже внушительно. Посмотрим на функцию для чисел Фибоначчи:

<blockquote>fibs&nbsp;<font color="#339933">=</font>&nbsp;<font>0</font>&nbsp;:&nbsp;<font>1</font>&nbsp;:&nbsp;<font>zipWith</font>&nbsp;<font>&#40;</font><font color="#339933">+</font><font>&#41;</font>&nbsp;fibs&nbsp;<font>&#40;</font><font>tail</font>&nbsp;fibs<font>&#41;</font></blockquote>

Выглядит выражение (да и работает тоже!) очень красиво. Попробуем построить эскиз для него, помня о том, что знак “двоеточие”, использованный дважды, записан в инфиксной форме, а zipWith - это функция, принимающая три аргумента: (+), fibs и (tail fibs). Проблема здесь появляется с плюсом в скобках. Знак передается в другую функцию как аргумент, - и для Haskell это нормальное и очень полезное явление, известное как “функция высшего порядка”. Дополнительно, у оператора + откушены оба его собственных аргумента, - и это уже называется сечением. Согласно нашим прошлым правилам, оператор + должен стать конечным аргументом с увеличенной коробкой. В принципе, это нормально:

=============(эскиз, где плюс - отдельная коробка-переменная)===========

Но заглядывая в будущее, мы можем поразмышлять над тем, как в целом будут выглядеть сечения и каррированые функции. Возьмем для примера такой немного искусственный код:

<blockquote>ops&nbsp;<font color="#339933">=</font>&nbsp;<font>&#91;</font><font>&#40;</font><font color="#339933">+</font><font>&#41;</font><font color="#339933">,</font>&nbsp;<font>&#40;</font><font color="#339933">*</font><font>&#41;</font><font color="#339933">,</font>&nbsp;<font>&#40;</font><font color="#339933">-</font><font>&#41;</font><font>&#93;</font><br/>
&nbsp;<br/>
func&nbsp;x&nbsp;y&nbsp;op&nbsp;<font color="#339933">=</font>&nbsp;x&nbsp;`op`&nbsp;y<br/>
&nbsp;<br/>
result&nbsp;<font color="#339933">=</font>&nbsp;<font>map</font>&nbsp;<font>&#40;</font>func&nbsp;<font>2</font>&nbsp;<font>3</font><font>&#41;</font>&nbsp;ops</blockquote>

Здесь три функции: ops возвращает список операторов, func - производит над аргументами x и y действие, переданное как op, а внутри result это всё используется и что-то вычисляется. Если быть честным, при выполнении result вернет такой список: [5, 6, -1], и нетрудно проследить, как он получился. Функцией map функция (func 2 3) была применена ко всем операторам из списка ops. Нас в данном случае интересует, что (func 2 3) - это каррированая запись, у которой один аргумент остается вакантным. Операторы в скобках тоже каррированы (правильнее сказать - усечены), у них все уже украдено до нас... то есть, отобраны по два аргумента. В коде Haskell это никак не отражается, и странная запись вроде такой:

<blockquote>nullMap&nbsp;<font color="#339933">=</font>&nbsp;<font>map</font>&nbsp;<font>null</font></blockquote>

может ни о чем нам и не сказать, если не знать, что делают функции map и null, и если сигнатуры типов не указаны. Однако в визуализации мы могли бы чётко показать, что эти функции требуют еще какие-то аргументы. Достаточно постулировать, чтобы аргументы помещались в пазы функций, и количество пазов соответствовало арности. Вот результат для функций result и nullMap:

===========(2 экскиза)===========

При дизайне вычислительных выражений еще остается существенным вопрос о пропорциях, и тут возможен тотальный разгул фантазии. Параметризации поддаются высота элементов, расстояние между аргументами, длина и глубина пустого паза, высота и длина конечных элементов, размер пирамидального отступа. Если же вооружиться знаниями о гармонии то, наверное, стоит внести в пропорции магическое золотое сечение. Оно всё делает лучше!

Важной конструкцией любого языка являются условные переходы. В Haskell оператор if тоже есть, и он таков, что оператор else обязательно должен ему сопутствовать. Не может быть выражения, у которого одна из альтернатив отсутствует, - в мире, где всё есть функция, результат должен возвращаться всегда. Ниже представлено вычисление факториала с if (мы, как и в прошлый раз, не задумываемся о том, что n может прийти отрицательный):

<blockquote>fact&nbsp;n&nbsp;<font color="#339933">=</font>&nbsp;<font>if</font>&nbsp;n&nbsp;<font color="#339933">==</font>&nbsp;<font>0</font>&nbsp;<font>then</font>&nbsp;<font>1</font>&nbsp;<font>else</font>&nbsp;fact&nbsp;<font>&#40;</font>n&nbsp;<font color="#339933">-</font>&nbsp;<font>1</font><font>&#41;</font>&nbsp;<font color="#339933">*</font>&nbsp;n</blockquote>

Форматировать код здесь можно по-всякому. then и else не чувствительны к отступам и могут быть расположены на новой строке (только отсчитывая хотя бы один пробельный символ от функции fact):

<blockquote>fact&nbsp;n&nbsp;<font color="#339933">=</font>&nbsp;<font>if</font>&nbsp;n&nbsp;<font color="#339933">==</font>&nbsp;<font>0</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>then</font>&nbsp;<font>1</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>else</font>&nbsp;fact&nbsp;<font>&#40;</font>n&nbsp;<font color="#339933">-</font>&nbsp;<font>1</font><font>&#41;</font>&nbsp;<font color="#339933">*</font>&nbsp;n</blockquote>

Возможно, эти перестановки как-то помогут придумать дизайн данной конструкции. Наивный перенос слов if, then и else как самых нижних слоев пирамид, несколько пересекается с прошлым вариантом и сбивает с толку. Но вот если разделить их каким-нибудь обособленным элементом, получится уже интереснее. Сравните два следующих варианта:

==========(2 эскиза if: без разделений и с разделениями)===========

Давая волю фантазии, можно добиться некоторой интуитивности последнего варианта. Ведь что такое if? Это когда булевое выражение проверяется на истинность, то есть, на совпадение с True. На принципе совпадения построены конструкторы, паззлы и кое-что ещё: есть совпадение, - штырь подходит к пазу; нет совпадения, - ну, извините... Попробуем внести эту концепцию в эскиз:

==========(2 эскиза паззлового if)=========

Выглядит интересно и побуждает фантазировать дальше. Можно экспериментировать с положением, формой, размерами, но нужно не забывать о том, что if-then-else - это выражение, и оно будет использоваться внутри других выражений. То есть, раз уж мы ограничиваем себя в пространстве ради выразительности, то и условный оператор не должен выходить за некие эмпирические рамки.

Возможно, для if-then-else это и не трудно, и эти синтаксические элементы, как паиньки, поместятся в любой части выражения, но вот родственная case-конструкция может доставить хлопот. Она умеет расширяться: количество альтернатив ничем не ограничено. Перепишем функцию факториала:

<blockquote>fact&nbsp;n&nbsp;<font color="#339933">=</font>&nbsp;<font>case</font>&nbsp;n&nbsp;<font color="#339933">==</font>&nbsp;<font>0</font>&nbsp;<font>of</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;True&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>1</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;False&nbsp;<font color="#339933">-&gt;</font>&nbsp;fact&nbsp;<font>&#40;</font>n&nbsp;<font color="#339933">-</font>&nbsp;<font>1</font><font>&#41;</font>&nbsp;<font color="#339933">*</font>&nbsp;n</blockquote>

Есть над чем подумать. В case-конструкции добавляется новая семантика: сопоставление с образцом. Тут я, признаться, еще не придумал достойного варианта. Но можно попробовать по аналогии с одним из последних эскизов if:

============(эскиз с case, аналогичный if’у - 15)==============

Смысл сопоставления с образцом в том, что на каждом из кубиков перед знаком "->" может быть достаточно большое выражение. Возможности огромны: здесь и расщепление списков, и сколь угодно глубокое сопоставление с алгебраическими типами данных, и даже - с подключенным расширением языка View Patterns - некий синтаксис, напоминающий функции. Я покажу лишь простой, достаточно типичный код, где используется pattern matching внутри case:

<blockquote>toHabrFormat&nbsp;<font>&#40;</font>s<font color="#339933">,</font>&nbsp;<font>&#40;</font>ch:<font>&#91;</font><font>&#93;</font><font>&#41;</font><font>&#41;</font>&nbsp;<font color="#339933">=</font>&nbsp;s&nbsp;<font color="#339933">++</font>&nbsp;<font>&#91;</font>ch<font>&#93;</font><br/>
toHabrFormat&nbsp;a<font color="#339933">@</font><font>&#40;</font>s<font color="#339933">,</font>&nbsp;b<font color="#339933">@</font><font>&#40;</font>ch:inStr<font>&#41;</font><font>&#41;</font>&nbsp;<font color="#339933">=</font>&nbsp;<font>let</font>&nbsp;formatted&nbsp;<font color="#339933">=</font>&nbsp;<font>&#40;</font><font>foldr1</font>&nbsp;<font>&#40;</font><font color="#339933">&lt;|&gt;</font><font>&#41;</font>&nbsp;formatters<font>&#41;</font>&nbsp;a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>in</font>&nbsp;<font>case</font>&nbsp;formatted&nbsp;<font>of</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just&nbsp;<font>&#40;</font>res<font color="#339933">,</font>&nbsp;<font>&#91;</font><font>&#93;</font><font>&#41;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;res<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just&nbsp;<font>&#40;</font>res<font color="#339933">,</font>&nbsp;<font>&#40;</font>r:rs<font>&#41;</font><font>&#41;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;toHabrFormat&nbsp;<font>&#40;</font>res&nbsp;<font color="#339933">++</font>&nbsp;<font>&#91;</font>r<font>&#93;</font><font color="#339933">,</font>&nbsp;rs<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nothing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;toHabrFormat&nbsp;<font>&#40;</font>s&nbsp;<font color="#339933">++</font>&nbsp;<font>&#91;</font>ch<font>&#93;</font><font color="#339933">,</font>&nbsp;inStr<font>&#41;</font></blockquote>

Видимо, пока нет ясности о том, как представлять алгебраические типы данных, списки, кортежи и прочее - case-конструкция будет неубедительной.

Сейчас, всё же, отложим в сторону вычислительные выражения и попробуем завершить визуализацию функции факториала с её именем и охранными выражениями.

<blockquote>fact&nbsp;n&nbsp;<font color="#339933">|</font>&nbsp;n&nbsp;<font color="#339933">==</font>&nbsp;<font>0</font>&nbsp;<font color="#339933">=</font>&nbsp;<font>1</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">|</font>&nbsp;n&nbsp;<font color="#339933">/=</font>&nbsp;<font>0</font>&nbsp;<font color="#339933">=</font>&nbsp;fact&nbsp;<font>&#40;</font>n&nbsp;<font color="#339933">-</font>&nbsp;<font>1</font><font>&#41;</font>&nbsp;<font color="#339933">*</font>&nbsp;n</blockquote>

Об охранных выражениях есть что сказать. Это обычные выражения, но возвращают они всегда булевое значение - True или False. Они служат некими фильтрами, как бы не пропуская выполнение в тело, если условие не истинно. Играя с этой концепцией, можно придумать что-то вроде пресловутого if. Оценим следующий вариант:

==========(грубый эскиз guard вместе с телом функции - 16)=========

Коробка с равенством (”мост”) появилась из желания соединить охранные выражения и тело функции так же, как в коде. И это, кажется, интересная идея. Развиваясь, она переросла в нечто большее - в визуальное разделение частей (имя функции; охранные выражения; вычислительное выражение). Можно пойти дальше: поместить их на платформы, очертив тем самым пространство каждой из частей.

=========(эскиз булевого охранного выражения без рамки и тела функции на платформе - 17)===========

В коде охранное выражение начинается с символа ‘|’. Если бы его не было, код выглядел бы противоречиво:

<blockquote>fact&nbsp;n&nbsp;&nbsp;n&nbsp;<font color="#339933">==</font>&nbsp;<font>0</font>&nbsp;<font color="#339933">=</font>&nbsp;<font>1</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;<font color="#339933">/=</font>&nbsp;<font>0</font>&nbsp;<font color="#339933">=</font>&nbsp;fact&nbsp;<font>&#40;</font>n&nbsp;<font color="#339933">-</font>&nbsp;<font>1</font><font>&#41;</font>&nbsp;<font color="#339933">*</font>&nbsp;n</blockquote>

Компилятор бы не понимал, чем являются буквы и символы после слова fact. Вертикальная черта - необходимый элемент синтаксиса, и поэтому нам нужно его внести в визуализацию. Логично поставить что-нибудь слева от платформы с булевым выражением; это может быть, например, “стена”:

============(эскиз вертикальной черты виде стены и булевое выражение - 18)===========

Но так ли это интуитивно? Сплошная коробка выглядит препятствием, запретом, а нам нужны - условие, вариативность. Если мы представим ход выполнения в виде кубика, то он, двигаясь от имени функции к охранному выражению, просто столкнется со стеной, - и ни одно из тел функции не будет достигнуто. В этом размышлении кроется ключ к более интуитивному варианту: а что если сделать в стене отверстие? Можно мыслить себе так: если логическое условие истинно, кубик пройдет сквозь отверстие и попадет, куда нужно. Направление движения тоже стоит визуализировать: пусть его показывают мосты со стрелками, - они также помогут соединить правую и левую часть функции:

===========(полный эскиз охранного выражения с мостами - 19)============

Гораздо лучше! Теперь визуализируем имя функции с аргументами. Опять же, здесь мы имеем дело с pattern matching, и, по-хорошему, его стоило бы совместить с арностью. Вырезы для аргументов мы уже научились делать, они пригодятся и здесь. Без сопоставления с образцом у нас был бы такой вариант:

=========(полный эскиз имени функции без сопоставления с образцом - 20)=============

Итак, построена основа графического языка, и мы теперь примерно представляем, как он должен выглядеть. Для ясной картины еще нужно разобраться с такими важными вещами, как алгебраические типы данных, списки, кортежи и сопоставление с образцом. Когда с ними будет покончено, скорее всего появятся идеи, что делать с декларациями типов, с do-конструкциями, генераторами списков, as-образцами, типами классов, воплощениями классов и прочими замечательными элементами Haskell-синтаксиса.

Начнем с алгебраических типов данных, списков и сопоставления с образцом. Выше в примере с case мы уже попробовали визуализировать АТД и pattern matching. Представим, что арность вместо вырезов обозначается выступами. Картинка с case, True и False тогда будет неверной, потому что у этих двух конструкторов арность равна нулю. Однако, арность Just равна 1, - и у него будет один выступ.

==========(эскизы True, False, Just, Nothing - 21)===========

Списки создаются через инфиксный оператор ":". Мы уже умеем его визуализировать. Возьмем более сложный случай, - когда есть и "неважные" элементы, и пустой список. Вот гипотетический код:

<blockquote>someFunc&nbsp;someList&nbsp;<font color="#339933">=</font>&nbsp;<font>case</font>&nbsp;someList&nbsp;<font>of</font><br/>
    <font>&#40;</font>x1:x2:<font color="#339933">_</font>:xs<font>&#41;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;Just&nbsp;<font>&#40;</font>x1<font color="#339933">,</font>&nbsp;x2<font>&#41;</font><br/>
    <font>&#40;</font>x1:<font>&#91;</font><font>&#93;</font><font>&#41;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;Just&nbsp;<font>&#40;</font>x1<font color="#339933">,</font>&nbsp;x1<font>&#41;</font><br/>
    <font>&#91;</font><font>&#93;</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">-&gt;</font>&nbsp;Nothing</blockquote>

Уже сами конструкции языка Haskell наглядно показывают свою суть. Неважный аргумент заменяется знаком подчеркивания, а пустой список - пустыми квадратными скобками. Учтем это при визуализации. Не видно в формализме кода только различий между аргументами x1, x2 и xs из первой альтернативы. Между тем, x1 и x2 - это отщепленные спереди элементы списка, а xs - это весь остальной возможно пустой список. Полезно было бы разницу как-то показать.

===========(2 эскиза для списков из кода. Пустой элемент - плоская коробка с дырками. 22 23)==============

Да, списки выглядят очень. Особенно мне нравится "неважный" элемент. А что насчет кортежей? Ну, мудрить незачем: просто поместим каждый элемент кортежа в паз на общей доске. С функцией спутать нельзя, так как у кортежа нет имени, и его основание тоньше. Для надежности можно изменить цвет.

===========(эскиз кортежа 24)=============

Не такая уж и трудная задача оказалась! Вот так, логически рассуждая, можно построить язык для визуализации. Ничего страшного, если какие-то конструкции будут изменены до неузнаваемости через несколько версий. Сейчас, не затронув то, как визуализировать декларацию типов, я рискую потом обнаружить, что они не вписываются в полуготовую схему. Придется что-нибудь изменять, чем-нибудь жертвовать, но общие принципы визуализации останутся прежними. Конечно, для фантазии остались огромные просторы. Я еще не подбирал цвета и оттенки, не думал над шрифтами, да и форма элементов может быть улучшена во многих смыслах. Была даже такая идея: коробки с надписями сделать стеклянными, а надпись поместить внутрь, и заставить это всё переливаться отраженным светом. Увековечить, так сказать, код в стекле. Наверное, получилось бы что-то вроде этого:

==========(картинка со стеклом полной функции - 25)=========

Красота, что и говорить. И уже кажется, что основные затраты здесь - на выдумывание дизайна, а визуализацию можно быстро состряпать в каком-нибудь графическом редакторе, но... В реальности всё несколько сложнее, потому что для визуализации нужна программа, а не статичная 3D-сцена. Именно такую программу я и создаю в проекте "GraphServer". Задача осложняется тем, что не для всех конструкций я придумал визуализацию; уже при написании этой статьи были сильно изменены или изобретены некоторые конструкции. Но даже то, что готово на данный момент, выглядит многообещающе.

Это кросс-статья. О создании сервера визуализации читайте в статье "Haskell - Эстетика".