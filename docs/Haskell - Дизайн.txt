Говорят, каждый программист должен в своей жизни написать хотя бы один компилятор или придумать какой-нибудь язык программирования. Дизайн нового языка - дело непростое, ведь нужно продумать десятки параметров, которые, как кубики Lego, должны хорошо между собой сочетаться. Одно неудачное решение может перечеркнуть судьбу языка, когда он еще даже не вышел в свет. Сотни языков прозябают в забвении, подвинутые с подиума старшими братьями, но мир с упорством, достойным лучшего применения, рождает ежегодно два-три новых. Попадут ли они хотя бы в "группу альтернативного мировоззрения", или даже станут мэйнстримными, покажет время. К счастью, моему языку это не нужно, поскольку на нем нельзя программировать, - им можно только любоваться. Ибо это язык визуализации Haskell-кода, о дизайне которого пойдет речь в статье.

===============(картинка - эскиз функции)===============

Haskell - замечательный язык. Он очень выразительный и емкий. Код получается на порядок компактнее кода на императивных языках (C++, Java, C#), несмотря на то, что в нем меньше синтаксических конструкций. Чистая функциональная природа Haskell и его дизайн способствуют тому, что код становится похож на математическую запись. Возьмем для примера показательный (но не лучший) вариант факториала:

fact n | n == 0 = 1
       | n >  0 = n * fact (n-1)

В этих двух строчках отлично узнается знакомая со школы рекуррентная формула факториала:

==============(картинка с Википедии)===========

Конечно, определенный рекурсивно факториал не будет сильно хуже на любом другом языке, что может вызвать сомнения, а так уж ли Haskell выразителен.

int fact(int n)
{
    if (n == 0) return 1;
    return n * fact (n - 1);
}

Фокус в том, что обе функции написаны в функциональном стиле, поэтому между ними особой разницы и нет. Однако, пожалев стек, мы могли бы в императивном языке использовать цикл, что выглядит уже совсем по-другому:

int fact(int n)
{
    int f = 1;
    for (int i = 2; i <= n; ++i)
        f *= i;
    return f;
}

Программисты хорошо знают о том, что визуализировать последние два примера можно с помощью блок-схемы:

=====================(2 блок-схемы: рекурсивная, циклическая)====================

Первая схема, в принципе, описывает, что происходит и в рекурсивном коде на Haskell. И хотя блок-схемы - это визуализация, они все-таки отличаются от того, что хочу я: они показывают, __что__ происходит, а не __как выглядит__. Я же хочу перенести код на трехмерную сцену, - так, чтобы сцена получилась красивой, интуитивной и, по возможности необычной. Смысл визуализации есть это.

При дизайне языка приходится думать над тем, как его потом расширять. Сделаешь неверно или неудобно, - и новым затеям не будет места без того, чтобы разрушить обратную совместимость. Истории такие примеры известны; не миновала сия чаша даже некоторые очень популярные языки (например, Python 3.0, который не совместим с ранними версиями). В значительной мере на расширяемость дизайна влияют совсем малые вещи, так сказать, синтаксис в малом. При удачных детальках весь язык строится как один большой и хорошо продуманный конструктор. Haskell из таких, а значит, язык визуализации тоже должен держать марку. И тут я даже не могу сделать скидку на то, что дизайн Haskell известен, - мне все равно приходится преодолевать эти трудности с самого начала. Хотя в некотором смысле мне, конечно же, проще.

Итак, нужно продумать дизайн графического языка, достаточно самостоятельный, но при этом наглядный и эстетически полезный. Думать нужно над отдельными синтаксическими единицами, при этом поглядывая на уровень выше - на их связь и на их значение в общей канве. Отталкиваясь от того самого факториала, я планирую когда-нибудь придумать эскизы даже для такого вот Haskell-кода:

-- | Collects actions for specified box side drawings.
-- | It should be used only in this module.
f :: PreparedTextureObjects
    -> GLfVertex3 
    -> (BoxSide, QuadColorSpec)
    -> ([BoxSide], [IO()])
    -> ([BoxSide], [IO()])
f texRes boxDim (side, qColorSpec) (sList, ioList) = let
    boxIO = do  setQuadColorSpec texRes qColorSpec
                GL.renderPrimitive GL.Quads (boxSide boxDim side)
    in (side : sList, boxIO : ioList) 

Или для такого:

data QuadColorSpec = QuadTexture TextureName
                   | QuadPlainColor GLfColor4
                   | NoQuadColorSpec
    deriving (Show)

data ObjectTextureSpec = BoxTextureSpec
        { quadSideTexes  :: [(BoxSide, QuadColorSpec)]
        , defQuadSideTex :: QuadColorSpec
        } deriving (Show)

data CornerCoord = UR | DR | DL | UL 
    deriving (Show)

А пока у меня есть код факториала, с него и начинался язык визуализации:

fact n | n == 0    = 1
       | otherwise = fact (n - 1) * n

Здесь мы видим несколько синтаксических конструкций:

название функции     - fact
2 охранных выражения - | n == 0
                     - | otherwise
2 тела функции       - = 1
                       = fact (n - 1) * n

В свою очередь, каждое тело функции разбивается на древовидное вычислительное выражение. Возьмем второй случай. Представляя элементы этого дерева в виде коробок, мы получим первый грубый вариант:

============(грубый эскиз выражения в непирамидальной форме)==================

И сразу же проступают недостатки. Можно представить, как вырастет визуализация кода, если добавить в тело функции еще каких-нибудь действий и выражений. Да что там! Выражения могут сами состоять из выражений, и простое соотнесение каждого элемента с коробкой приведет к тому, что мы просто получим длинную и неинтуитивную цепь из коробок. Решение "в лоб" здесь не подходит. Вспомним полезный факт: явным воплощением древовидной конструкции является пирамида. Вычислительное выражение тоже можно представить в таком виде, причем даже несколькими способами:

=========(3 эскиза выражения в пирамидальной форме без контроля выступов)============

Последняя картинка субъективно симпатичнее за счет характерных пирамидальных выступов. Можно было бы остановиться на этой форме, но есть у бинарных функций особенность, что они могут быть операторами. Отличие операторов от функций чисто интуитивное, а с точки зрения языка это одно и то же, просто по-разному записывается - в функциональной и инфиксной записях:

isListElement x xs = elem x xs -- функциональная форма
isListElement’ x xs = x `elem` xs -- инфиксная форма

Операторы по умолчанию используются в инфиксной записи, но допустима и функциональная тоже:

add a b = a + b
add’ a b = (+) a b

И этот факт можно легко отобразить при визуализации. На следующем эскизе помимо выделения инфиксной формы я увеличил конечные синтаксические единицы (переменные и константы) в два раза:

================(Финальный эскиз пирамидального выражения)===============

Уменьшилась высота пирамиды, что хорошо, и стало видно, где инфиксная запись, а где - функциональная. Такой подход становится полезен при задании идущих подряд вычислений:

add3 a b c = a + b + c
someF x y z = x >>= y >>= z

А для функций с большим числом аргументов стоит сохранить промежуток между коробками.

========(Эскиз (2 картинки) с последовательными инфиксными выражениями)==========

=======(Эскиз foldr с 3 аргументами)==========

На эскизах видно, что длина коробок зависит от названия на коробке и от места, занимаемого аргументами. Тут уж ничего не поделаешь: надпись нужна, и уменьшать ее в размерах не стоит, иначе мы потеряем единообразие. Это на web-страничке или в документе каком-нибудь можно шрифты подгонять, а код должен выглядеть строго, потому что его так легче читать. Поэтому сложные, массивные вычислительные выражения будут выглядеть тоже внушительно. Посмотрим на функцию для чисел Фибоначчи:

fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

Выглядит выражение (да и работает тоже!) очень красиво. Попробуем построить эскиз для него, помятуя о том, что знак “двоеточие”, использованный дважды, записан в инфиксной форме, а zipWith - это функция, принимающая три аргумента: (+), fibs и (tail fibs). Проблема здесь появляется с плюсом в скобках. Знак передается в другую функцию как аргумент, - и для Haskell это нормальное и очень полезное явление, известное как “функция высшего порядка”. Дополнительно, у оператора + откушены оба его собственных аргумента, - и это уже называется сечением. Согласно нашим прошлым правилам, оператор + должен стать конечным аргументом с увеличенной коробкой. В принципе, это нормально:

=============(эскиз, где плюс - отдельная коробка-переменная)===========

Но заглядывая в будущее, мы можем поразмышлять над тем, как в целом будут выглядеть сечения и каррированые функции. Возьмем для примера такой немного искусственный код:

ops = [(+), (*), (-)]

func x y op = x `op` y

result = map (func 2 3) ops

Здесь три функции: ops возвращает список операторов, func - производит над аргументами x и y действие, переданное как op, а внутри result это всё используется и что-то вычисляется. Если быть честным, при выполнении result вернет такой список: [5, 6, -1], и нетрудно проследить, как он получился. Функцией map функция (func 2 3) была применена ко всем операторам из списка ops. Нас в данном случае интересует, что (func 2 3) - это каррированая запись, у которой один аргумент остается вакантным. Операторы в скобках тоже каррированы (правильнее сказать - усечены), у них все уже украдено до нас... то есть, отобраны по два аргумента. В коде Haskell это никак не отражается, и странная запись вроде такой:

nullMap = map null

может ни о чем нам и не сказать, если не знать, что делают функции map и null, и если сигнатуры типов не указаны. Однако в визуализации мы могли бы чётко показать, что эти функции требуют еще какие-то аргументы. Достаточно постулировать, чтобы аргументы помещались в пазы функций, и количество пазов соответствовало арности. Вот результат для функций result и nullMap:

===========(2 экскиза)===========

Конечно, о типе принимаемых аргументов тут никакой информации нет, но такая визуализация уже более информативна.

При дизайне вычислительных выражений еще остается существенным вопрос о пропорциях, и тут возможен тотальный разгул фантазии. Параметризации поддаются высота элементов, расстояние между аргументами, длина и глубина пустого паза, высота и длина конечных элементов, размер пирамидального отступа. Лучше всего при программировании визуализации создать такой код, который бы позволял это все настраивать. Если же вооружиться знаниями о гармонии то, наверное, стоит внести в пропорции магическое золотое сечение. Оно всё делает лучше!

Важной конструкцией любого языка являются условные переходы. В Haskell оператор if тоже есть, и он таков, что оператор else обязательно должен ему сопутствовать. Не может быть выражения, у которого одна из альтернатив отсутствует, - это нарушение того, что вся конструкция if должна быть тоже выражением. Вот вычисление факториала с if (мы, как и в прошлый раз, не задумываемся о том, что n может прийти отрицательный):

fact n = if n == 0 then 1 else fact (n - 1) * n

Форматировать код здесь можно по-всякому. then и else не чувствительны к отступам и могут быть расположены на новой строке (отсчитывая только хотя бы один пробельный символ от функции fact):

fact n = if n == 0
      then 1
      else fact (n - 1) * n

Возможно, эти перестановки как-то помогут придумать дизайн данной конструкции. Наивный перенос слов if, then и else как самых нижних слоев пирамид, несколько пересекается с прошлым вариантом и сбивает с толку. Но вот если разделить эти элементы каким-нибудь обособленным элементом, получится уже интереснее. Сравните два следующих варианта:

==========(2 эскиза if: без разделений и с разделениями)===========

Давая волю фантазии, можно добиться некоторой интуитивности последнего варианта. Ведь что такое if? Это некий проверка на истинность булевого выражения. Чем бы вы выразили совпадение в каком-нибудь конструкторе? Пазом и штырем. Или же можно вспомнить паззл: паззлах тоже пазы. Попробуем внести эту концепцию в эскиз:

==========(эскиз паззлового if)=========

Выглядит интересно и пробуждает желание фантазировать дальше. Можно эскпериментировать с положением, формой, размерами, но нужно не забывать о том, что if-then-else - это выражение, и оно будет использоваться внутри других выражений. То есть, раз уж мы ограничиваем себя в пространстве ради выразительности, то и условный оператор не должен выходить за некие эпирические рамки.